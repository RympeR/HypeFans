{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _jsxFileName = \"D:\\\\develop\\\\pypr\\\\HypeFans\\\\mobile_version\\\\node_modules\\\\expo-image-editor\\\\lib\\\\ImageCropOverlay.js\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImageCropOverlay = void 0;\n\nvar React = __importStar(require(\"react\"));\n\nvar react_native_1 = require(\"react-native-web/dist/index\");\n\nvar recoil_1 = require(\"recoil\");\n\nvar Store_1 = require(\"./Store\");\n\nvar react_native_gesture_handler_1 = require(\"react-native-gesture-handler\");\n\nvar horizontalSections = [\"top\", \"middle\", \"bottom\"];\nvar verticalSections = [\"left\", \"middle\", \"right\"];\n\nfunction ImageCropOverlay() {\n  var _this = this;\n\n  var _React$useState = React.useState(\"\"),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      selectedFrameSection = _React$useState2[0],\n      setSelectedFrameSection = _React$useState2[1];\n\n  var _recoil_1$useRecoilSt = recoil_1.useRecoilState(Store_1.cropSizeState),\n      _recoil_1$useRecoilSt2 = _slicedToArray(_recoil_1$useRecoilSt, 2),\n      cropSize = _recoil_1$useRecoilSt2[0],\n      setCropSize = _recoil_1$useRecoilSt2[1];\n\n  var _recoil_1$useRecoilSt3 = recoil_1.useRecoilState(Store_1.imageBoundsState),\n      _recoil_1$useRecoilSt4 = _slicedToArray(_recoil_1$useRecoilSt3, 1),\n      imageBounds = _recoil_1$useRecoilSt4[0];\n\n  var _recoil_1$useRecoilSt5 = recoil_1.useRecoilState(Store_1.accumulatedPanState),\n      _recoil_1$useRecoilSt6 = _slicedToArray(_recoil_1$useRecoilSt5, 2),\n      accumulatedPan = _recoil_1$useRecoilSt6[0],\n      setAccumluatedPan = _recoil_1$useRecoilSt6[1];\n\n  var _recoil_1$useRecoilSt7 = recoil_1.useRecoilState(Store_1.fixedCropAspectRatioState),\n      _recoil_1$useRecoilSt8 = _slicedToArray(_recoil_1$useRecoilSt7, 1),\n      fixedAspectRatio = _recoil_1$useRecoilSt8[0];\n\n  var _recoil_1$useRecoilSt9 = recoil_1.useRecoilState(Store_1.lockAspectRatioState),\n      _recoil_1$useRecoilSt10 = _slicedToArray(_recoil_1$useRecoilSt9, 1),\n      lockAspectRatio = _recoil_1$useRecoilSt10[0];\n\n  var _recoil_1$useRecoilSt11 = recoil_1.useRecoilState(Store_1.minimumCropDimensionsState),\n      _recoil_1$useRecoilSt12 = _slicedToArray(_recoil_1$useRecoilSt11, 1),\n      minimumCropDimensions = _recoil_1$useRecoilSt12[0];\n\n  var _React$useState3 = React.useState({\n    width: new react_native_1.Animated.Value(cropSize.width),\n    height: new react_native_1.Animated.Value(cropSize.height)\n  }),\n      _React$useState4 = _slicedToArray(_React$useState3, 1),\n      animatedCropSize = _React$useState4[0];\n\n  var panX = React.useRef(new react_native_1.Animated.Value(imageBounds.x));\n  var panY = React.useRef(new react_native_1.Animated.Value(imageBounds.y));\n  React.useEffect(function () {\n    checkCropBounds({\n      translationX: 0,\n      translationY: 0\n    });\n    animatedCropSize.height.setValue(cropSize.height);\n    animatedCropSize.width.setValue(cropSize.width);\n  }, [cropSize]);\n  React.useEffect(function () {\n    var newSize = {\n      width: 0,\n      height: 0\n    };\n    var width = imageBounds.width,\n        height = imageBounds.height;\n    var imageAspectRatio = width / height;\n\n    if (fixedAspectRatio < imageAspectRatio) {\n      newSize.height = height;\n      newSize.width = height * fixedAspectRatio;\n    } else {\n      newSize.width = width;\n      newSize.height = width / fixedAspectRatio;\n    }\n\n    setCropSize(newSize);\n  }, [imageBounds]);\n\n  var isMovingSection = function isMovingSection() {\n    return selectedFrameSection == \"topmiddle\" || selectedFrameSection == \"middleleft\" || selectedFrameSection == \"middleright\" || selectedFrameSection == \"middlemiddle\" || selectedFrameSection == \"bottommiddle\";\n  };\n\n  var isLeft = selectedFrameSection.endsWith(\"left\");\n  var isTop = selectedFrameSection.startsWith(\"top\");\n\n  var onOverlayMove = function onOverlayMove(_ref) {\n    var nativeEvent = _ref.nativeEvent;\n\n    if (selectedFrameSection !== \"\") {\n      if (isMovingSection()) {\n        react_native_1.Animated.event([{\n          translationX: panX.current,\n          translationY: panY.current\n        }], {\n          useNativeDriver: false\n        })(nativeEvent);\n      } else {\n        var _getTargetCropFrameBo = getTargetCropFrameBounds(nativeEvent),\n            x = _getTargetCropFrameBo.x,\n            y = _getTargetCropFrameBo.y;\n\n        if (isTop) {\n          panY.current.setValue(-y);\n        }\n\n        if (isLeft) {\n          panX.current.setValue(-x);\n        }\n\n        animatedCropSize.width.setValue(cropSize.width + x);\n        animatedCropSize.height.setValue(cropSize.height + y);\n      }\n    } else {\n      var _x = nativeEvent.x,\n          _y = nativeEvent.y;\n      var initialWidth = cropSize.width,\n          initialHeight = cropSize.height;\n      var position = \"\";\n\n      if (_y / initialHeight < 0.333) {\n        position = position + \"top\";\n      } else if (_y / initialHeight < 0.667) {\n        position = position + \"middle\";\n      } else {\n        position = position + \"bottom\";\n      }\n\n      if (_x / initialWidth < 0.333) {\n        position = position + \"left\";\n      } else if (_x / initialWidth < 0.667) {\n        position = position + \"middle\";\n      } else {\n        position = position + \"right\";\n      }\n\n      setSelectedFrameSection(position);\n    }\n  };\n\n  var getTargetCropFrameBounds = function getTargetCropFrameBounds(_ref2) {\n    var translationX = _ref2.translationX,\n        translationY = _ref2.translationY;\n    var x = 0;\n    var y = 0;\n\n    if (translationX < translationY) {\n      x = (isLeft ? -1 : 1) * translationX;\n\n      if (lockAspectRatio) {\n        y = x / fixedAspectRatio;\n      } else {\n        y = (isTop ? -1 : 1) * translationY;\n      }\n    } else {\n      y = (isTop ? -1 : 1) * translationY;\n\n      if (lockAspectRatio) {\n        x = y * fixedAspectRatio;\n      } else {\n        x = (isLeft ? -1 : 1) * translationX;\n      }\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var onOverlayRelease = function onOverlayRelease(nativeEvent) {\n    if (isMovingSection()) {\n      checkCropBounds(nativeEvent);\n    } else {\n      checkResizeBounds(nativeEvent);\n    }\n\n    setSelectedFrameSection(\"\");\n  };\n\n  var _onHandlerStateChange = function onHandlerStateChange(_ref3) {\n    var nativeEvent = _ref3.nativeEvent;\n\n    if (nativeEvent.state === react_native_gesture_handler_1.State.END) {\n      onOverlayRelease(nativeEvent);\n    }\n  };\n\n  var checkCropBounds = function checkCropBounds(_ref4) {\n    var translationX = _ref4.translationX,\n        translationY = _ref4.translationY;\n    var accDx = accumulatedPan.x + translationX;\n\n    if (accDx <= imageBounds.x) {\n      accDx = imageBounds.x;\n    } else if (accDx + cropSize.width > imageBounds.width + imageBounds.x) {\n        var limitedXPos = imageBounds.x + imageBounds.width - cropSize.width;\n        accDx = limitedXPos;\n      } else {}\n\n    var accDy = accumulatedPan.y + translationY;\n\n    if (accDy <= imageBounds.y) {\n      accDy = imageBounds.y;\n    } else if (accDy + cropSize.height > imageBounds.height + imageBounds.y) {\n        var limitedYPos = imageBounds.y + imageBounds.height - cropSize.height;\n        accDy = limitedYPos;\n      } else {}\n\n    panX.current.setValue(0);\n    panY.current.setValue(0);\n    setAccumluatedPan({\n      x: accDx,\n      y: accDy\n    });\n  };\n\n  var checkResizeBounds = function checkResizeBounds(_ref5) {\n    var translationX = _ref5.translationX,\n        translationY = _ref5.translationY;\n    var maxWidth = imageBounds.width,\n        maxHeight = imageBounds.height;\n    var minWidth = minimumCropDimensions.width,\n        minHeight = minimumCropDimensions.height;\n\n    var _getTargetCropFrameBo2 = getTargetCropFrameBounds({\n      translationX: translationX,\n      translationY: translationY\n    }),\n        x = _getTargetCropFrameBo2.x,\n        y = _getTargetCropFrameBo2.y;\n\n    var animatedWidth = cropSize.width + x;\n    var animatedHeight = cropSize.height + y;\n    var finalHeight = animatedHeight;\n    var finalWidth = animatedWidth;\n\n    if (animatedHeight > maxHeight) {\n      finalHeight = maxHeight;\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\n    } else if (animatedHeight < minHeight) {\n      finalHeight = minHeight;\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\n    }\n\n    if (animatedWidth > maxWidth) {\n      finalWidth = maxWidth;\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\n    } else if (animatedWidth < minWidth) {\n      finalWidth = minWidth;\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\n    }\n\n    setAccumluatedPan({\n      x: accumulatedPan.x + (isLeft ? -x : 0),\n      y: accumulatedPan.y + (isTop ? -y : 0)\n    });\n    panX.current.setValue(0);\n    panY.current.setValue(0);\n    setCropSize({\n      height: finalHeight,\n      width: finalWidth\n    });\n  };\n\n  return React.createElement(react_native_1.View, {\n    style: styles.container,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 275,\n      columnNumber: 13\n    }\n  }, React.createElement(react_native_gesture_handler_1.PanGestureHandler, {\n    onGestureEvent: onOverlayMove,\n    onHandlerStateChange: function onHandlerStateChange(e) {\n      return _onHandlerStateChange(e);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 276,\n      columnNumber: 7\n    }\n  }, React.createElement(react_native_1.Animated.View, {\n    style: [styles.overlay, animatedCropSize, {\n      transform: [{\n        translateX: react_native_1.Animated.add(panX.current, accumulatedPan.x)\n      }, {\n        translateY: react_native_1.Animated.add(panY.current, accumulatedPan.y)\n      }]\n    }],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 277,\n      columnNumber: 9\n    }\n  }, horizontalSections.map(function (hsection) {\n    return React.createElement(react_native_1.View, {\n      style: styles.sectionRow,\n      key: hsection,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 290,\n        columnNumber: 17\n      }\n    }, verticalSections.map(function (vsection) {\n      var key = hsection + vsection;\n      return React.createElement(react_native_1.View, {\n        style: [styles.defaultSection],\n        key: key,\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 293,\n          columnNumber: 21\n        }\n      }, key == \"topleft\" || key == \"topright\" || key == \"bottomleft\" || key == \"bottomright\" ? React.createElement(react_native_1.View, {\n        style: [styles.cornerMarker, hsection == \"top\" ? {\n          top: -4,\n          borderTopWidth: 7\n        } : {\n          bottom: -4,\n          borderBottomWidth: 7\n        }, vsection == \"left\" ? {\n          left: -4,\n          borderLeftWidth: 7\n        } : {\n          right: -4,\n          borderRightWidth: 7\n        }],\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 300,\n          columnNumber: 41\n        }\n      }) : null);\n    }));\n  }))));\n}\n\nexports.ImageCropOverlay = ImageCropOverlay;\nvar styles = react_native_1.StyleSheet.create({\n  container: {\n    height: \"100%\",\n    width: \"100%\",\n    position: \"absolute\"\n  },\n  overlay: {\n    height: 40,\n    width: 40,\n    backgroundColor: \"#33333355\",\n    borderColor: \"#ffffff88\",\n    borderWidth: 1\n  },\n  sectionRow: {\n    flexDirection: \"row\",\n    flex: 1\n  },\n  defaultSection: {\n    flex: 1,\n    borderWidth: 0.5,\n    borderColor: \"#ffffff88\",\n    justifyContent: \"center\",\n    alignItems: \"center\"\n  },\n  cornerMarker: {\n    position: \"absolute\",\n    borderColor: \"#ffffff\",\n    height: 30,\n    width: 30\n  }\n});","map":{"version":3,"sources":["../src/ImageCropOverlay.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageCropOverlay = void 0;\nconst React = __importStar(require(\"react\"));\nconst react_native_1 = require(\"react-native\");\nconst recoil_1 = require(\"recoil\");\nconst Store_1 = require(\"./Store\");\nconst react_native_gesture_handler_1 = require(\"react-native-gesture-handler\");\nconst horizontalSections = [\"top\", \"middle\", \"bottom\"];\nconst verticalSections = [\"left\", \"middle\", \"right\"];\nfunction ImageCropOverlay() {\n    // Record which section of the fram window has been pressed\n    // this determines whether it is a translation or scaling gesture\n    const [selectedFrameSection, setSelectedFrameSection] = React.useState(\"\");\n    // Shared state and bits passed through recoil to avoid prop drilling\n    const [cropSize, setCropSize] = recoil_1.useRecoilState(Store_1.cropSizeState);\n    const [imageBounds] = recoil_1.useRecoilState(Store_1.imageBoundsState);\n    const [accumulatedPan, setAccumluatedPan] = recoil_1.useRecoilState(Store_1.accumulatedPanState);\n    const [fixedAspectRatio] = recoil_1.useRecoilState(Store_1.fixedCropAspectRatioState);\n    const [lockAspectRatio] = recoil_1.useRecoilState(Store_1.lockAspectRatioState);\n    const [minimumCropDimensions] = recoil_1.useRecoilState(Store_1.minimumCropDimensionsState);\n    const [animatedCropSize] = React.useState({\n        width: new react_native_1.Animated.Value(cropSize.width),\n        height: new react_native_1.Animated.Value(cropSize.height),\n    });\n    // pan X and Y values to track the current delta of the pan\n    // in both directions - this should be zeroed out on release\n    // and the delta added onto the accumulatedPan state\n    const panX = React.useRef(new react_native_1.Animated.Value(imageBounds.x));\n    const panY = React.useRef(new react_native_1.Animated.Value(imageBounds.y));\n    React.useEffect(() => {\n        // Move the pan to the origin and check the bounds so it clicks to\n        // the corner of the image\n        checkCropBounds({\n            translationX: 0,\n            translationY: 0,\n        });\n        // When the crop size updates make sure the animated value does too!\n        animatedCropSize.height.setValue(cropSize.height);\n        animatedCropSize.width.setValue(cropSize.width);\n    }, [cropSize]);\n    React.useEffect(() => {\n        // Update the size of the crop window based on the new image bounds\n        let newSize = { width: 0, height: 0 };\n        const { width, height } = imageBounds;\n        const imageAspectRatio = width / height;\n        // Then check if the cropping aspect ratio is smaller\n        if (fixedAspectRatio < imageAspectRatio) {\n            // If so calculate the size so its not greater than the image width\n            newSize.height = height;\n            newSize.width = height * fixedAspectRatio;\n        }\n        else {\n            // else, calculate the size so its not greater than the image height\n            newSize.width = width;\n            newSize.height = width / fixedAspectRatio;\n        }\n        // Set the size of the crop overlay\n        setCropSize(newSize);\n    }, [imageBounds]);\n    // Function that sets which sections allow for translation when\n    // pressed\n    const isMovingSection = () => {\n        return (selectedFrameSection == \"topmiddle\" ||\n            selectedFrameSection == \"middleleft\" ||\n            selectedFrameSection == \"middleright\" ||\n            selectedFrameSection == \"middlemiddle\" ||\n            selectedFrameSection == \"bottommiddle\");\n    };\n    // Check what resizing / translation needs to be performed based on which section was pressed\n    const isLeft = selectedFrameSection.endsWith(\"left\");\n    const isTop = selectedFrameSection.startsWith(\"top\");\n    const onOverlayMove = ({ nativeEvent }) => {\n        if (selectedFrameSection !== \"\") {\n            // Check if the section pressed is one to translate the crop window or not\n            if (isMovingSection()) {\n                // If it is then use an animated event to directly pass the tranlation\n                // to the pan refs\n                react_native_1.Animated.event([\n                    {\n                        translationX: panX.current,\n                        translationY: panY.current,\n                    },\n                ], { useNativeDriver: false })(nativeEvent);\n            }\n            else {\n                // Else its a scaling operation\n                const { x, y } = getTargetCropFrameBounds(nativeEvent);\n                if (isTop) {\n                    panY.current.setValue(-y);\n                }\n                if (isLeft) {\n                    panX.current.setValue(-x);\n                }\n                // Finally update the animated width to the values the crop\n                // window has been resized to\n                animatedCropSize.width.setValue(cropSize.width + x);\n                animatedCropSize.height.setValue(cropSize.height + y);\n            }\n        }\n        else {\n            // We need to set which section has been pressed\n            const { x, y } = nativeEvent;\n            const { width: initialWidth, height: initialHeight } = cropSize;\n            let position = \"\";\n            // Figure out where we pressed vertically\n            if (y / initialHeight < 0.333) {\n                position = position + \"top\";\n            }\n            else if (y / initialHeight < 0.667) {\n                position = position + \"middle\";\n            }\n            else {\n                position = position + \"bottom\";\n            }\n            // Figure out where we pressed horizontally\n            if (x / initialWidth < 0.333) {\n                position = position + \"left\";\n            }\n            else if (x / initialWidth < 0.667) {\n                position = position + \"middle\";\n            }\n            else {\n                position = position + \"right\";\n            }\n            setSelectedFrameSection(position);\n        }\n    };\n    const getTargetCropFrameBounds = ({ translationX, translationY, }) => {\n        let x = 0;\n        let y = 0;\n        if (translationX < translationY) {\n            x = (isLeft ? -1 : 1) * translationX;\n            if (lockAspectRatio) {\n                y = x / fixedAspectRatio;\n            }\n            else {\n                y = (isTop ? -1 : 1) * translationY;\n            }\n        }\n        else {\n            y = (isTop ? -1 : 1) * translationY;\n            if (lockAspectRatio) {\n                x = y * fixedAspectRatio;\n            }\n            else {\n                x = (isLeft ? -1 : 1) * translationX;\n            }\n        }\n        return { x, y };\n    };\n    const onOverlayRelease = (nativeEvent) => {\n        // Check if the section pressed is one to translate the crop window or not\n        if (isMovingSection()) {\n            // Ensure the cropping overlay has not been moved outside of the allowed bounds\n            checkCropBounds(nativeEvent);\n        }\n        else {\n            // Else its a scaling op - check that the resizing didnt take it out of bounds\n            checkResizeBounds(nativeEvent);\n        }\n        // Disable the pan responder so the section tiles can register being pressed again\n        setSelectedFrameSection(\"\");\n    };\n    const onHandlerStateChange = ({ nativeEvent, }) => {\n        // Handle any state changes from the pan gesture handler\n        // only looking at when the touch ends atm\n        if (nativeEvent.state === react_native_gesture_handler_1.State.END) {\n            onOverlayRelease(nativeEvent);\n        }\n    };\n    const checkCropBounds = ({ translationX, translationY, }) => {\n        // Check if the pan in the x direction exceeds the bounds\n        let accDx = accumulatedPan.x + translationX;\n        // Is the new x pos less than zero?\n        if (accDx <= imageBounds.x) {\n            // Then set it to be zero and set the pan to zero too\n            accDx = imageBounds.x;\n        }\n        // Is the new x pos plus crop width going to exceed the right hand bound\n        else if (accDx + cropSize.width > imageBounds.width + imageBounds.x) {\n            // Then set the x pos so the crop frame touches the right hand edge\n            let limitedXPos = imageBounds.x + imageBounds.width - cropSize.width;\n            accDx = limitedXPos;\n        }\n        else {\n            // It's somewhere in between - no formatting required\n        }\n        // Check if the pan in the y direction exceeds the bounds\n        let accDy = accumulatedPan.y + translationY;\n        // Is the new y pos less the top edge?\n        if (accDy <= imageBounds.y) {\n            // Then set it to be zero and set the pan to zero too\n            accDy = imageBounds.y;\n        }\n        // Is the new y pos plus crop height going to exceed the bottom bound\n        else if (accDy + cropSize.height > imageBounds.height + imageBounds.y) {\n            // Then set the y pos so the crop frame touches the bottom edge\n            let limitedYPos = imageBounds.y + imageBounds.height - cropSize.height;\n            accDy = limitedYPos;\n        }\n        else {\n            // It's somewhere in between - no formatting required\n        }\n        // Record the accumulated pan and reset the pan refs to zero\n        panX.current.setValue(0);\n        panY.current.setValue(0);\n        setAccumluatedPan({ x: accDx, y: accDy });\n    };\n    const checkResizeBounds = ({ translationX, translationY, }) => {\n        // Check we haven't gone out of bounds when resizing - allow it to be\n        // resized up to the appropriate bounds if so\n        const { width: maxWidth, height: maxHeight } = imageBounds;\n        const { width: minWidth, height: minHeight } = minimumCropDimensions;\n        const { x, y } = getTargetCropFrameBounds({ translationX, translationY });\n        const animatedWidth = cropSize.width + x;\n        const animatedHeight = cropSize.height + y;\n        let finalHeight = animatedHeight;\n        let finalWidth = animatedWidth;\n        // Ensure the width / height does not exceed the boundaries -\n        // resize to the max it can be if so\n        if (animatedHeight > maxHeight) {\n            finalHeight = maxHeight;\n            if (lockAspectRatio)\n                finalWidth = finalHeight * fixedAspectRatio;\n        }\n        else if (animatedHeight < minHeight) {\n            finalHeight = minHeight;\n            if (lockAspectRatio)\n                finalWidth = finalHeight * fixedAspectRatio;\n        }\n        if (animatedWidth > maxWidth) {\n            finalWidth = maxWidth;\n            if (lockAspectRatio)\n                finalHeight = finalWidth / fixedAspectRatio;\n        }\n        else if (animatedWidth < minWidth) {\n            finalWidth = minWidth;\n            if (lockAspectRatio)\n                finalHeight = finalWidth / fixedAspectRatio;\n        }\n        // Update the accumulated pan with the delta from the pan refs\n        setAccumluatedPan({\n            x: accumulatedPan.x + (isLeft ? -x : 0),\n            y: accumulatedPan.y + (isTop ? -y : 0),\n        });\n        // Zero out the pan refs\n        panX.current.setValue(0);\n        panY.current.setValue(0);\n        // Update the crop size to the size after resizing\n        setCropSize({\n            height: finalHeight,\n            width: finalWidth,\n        });\n    };\n    return (<react_native_1.View style={styles.container}>\n      <react_native_gesture_handler_1.PanGestureHandler onGestureEvent={onOverlayMove} onHandlerStateChange={(e) => onHandlerStateChange(e)}>\n        <react_native_1.Animated.View style={[\n        styles.overlay,\n        animatedCropSize,\n        {\n            transform: [\n                { translateX: react_native_1.Animated.add(panX.current, accumulatedPan.x) },\n                { translateY: react_native_1.Animated.add(panY.current, accumulatedPan.y) },\n            ],\n        },\n    ]}>\n          {\n    // For reendering out each section of the crop overlay frame\n    horizontalSections.map((hsection) => {\n        return (<react_native_1.View style={styles.sectionRow} key={hsection}>\n                  {verticalSections.map((vsection) => {\n            const key = hsection + vsection;\n            return (<react_native_1.View style={[styles.defaultSection]} key={key}>\n                        {\n            // Add the corner markers to the topleft,\n            // topright, bottomleft and bottomright corners to indicate resizing\n            key == \"topleft\" ||\n                key == \"topright\" ||\n                key == \"bottomleft\" ||\n                key == \"bottomright\" ? (<react_native_1.View style={[\n                styles.cornerMarker,\n                hsection == \"top\"\n                    ? { top: -4, borderTopWidth: 7 }\n                    : { bottom: -4, borderBottomWidth: 7 },\n                vsection == \"left\"\n                    ? { left: -4, borderLeftWidth: 7 }\n                    : { right: -4, borderRightWidth: 7 },\n            ]}/>) : null}\n                      </react_native_1.View>);\n        })}\n                </react_native_1.View>);\n    })}\n        </react_native_1.Animated.View>\n      </react_native_gesture_handler_1.PanGestureHandler>\n    </react_native_1.View>);\n}\nexports.ImageCropOverlay = ImageCropOverlay;\nconst styles = react_native_1.StyleSheet.create({\n    container: {\n        height: \"100%\",\n        width: \"100%\",\n        position: \"absolute\",\n    },\n    overlay: {\n        height: 40,\n        width: 40,\n        backgroundColor: \"#33333355\",\n        borderColor: \"#ffffff88\",\n        borderWidth: 1,\n    },\n    sectionRow: {\n        flexDirection: \"row\",\n        flex: 1,\n    },\n    defaultSection: {\n        flex: 1,\n        borderWidth: 0.5,\n        borderColor: \"#ffffff88\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n    },\n    cornerMarker: {\n        position: \"absolute\",\n        borderColor: \"#ffffff\",\n        height: 30,\n        width: 30,\n    },\n});\n//# sourceMappingURL=ImageCropOverlay.js.map"]},"metadata":{},"sourceType":"script"}